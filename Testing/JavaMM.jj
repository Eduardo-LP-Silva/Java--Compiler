/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. JavaMM.jj */
/*@egen*///Podemos mudar LOOKAHEAD dinamicamente (p.exemplo para int vs int[])
options 
{
    LOOKAHEAD = 1;
}

PARSER_BEGIN(JavaMM)
    public class JavaMM/*@bgen(jjtree)*/implements JavaMMTreeConstants/*@egen*/
    {/*@bgen(jjtree)*/
  protected static JJTJavaMMState jjtree = new JJTJavaMMState();

/*@egen*/
        public static void main(String[] args) throws ParserException
        {
            if(args.length < 1)
            {
                System.out.println("Usage: JavaMM <filename>");
                System.exit(1);
            }

            JavaMM parser = new JavaMM(new FileInputStream(args[0]));
            SimpleNode root = parser.Program();

            System.out.println("-----AST-----");
            root.dump(" ");
            
        }
    }

PARSER_END(JavaMM)

SKIP :
{
    " " | "\r" | "\t"
}

// Ver palavras reservadas
TOKEN:
{
    
    <BOOL: "boolean">
    | <MAIN: "main">
    | <VOID: "void">
    | <STRING: "string">
    | <INT: ("int")>
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <ADD: "+">
    | <SUB: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <NOT: "!">
    | <EQUAL: "=">
    | <LOWER: "<">
    | <BIGGER: ">">
    | <AND: "&&">
    | <SEMI: ";">
    | <COMMA: ",">
    | <DOT: ".">
    | <RETURN: "return">
    | <PUBLIC: "public">
    | <STAT: "static">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <IF: "if">
    | <WHILE: "while">
    | <CLASS: "class">
    | <EXT: "extends">
    | <INTEGER: (["0"-"9"])+>
    | <IDENTIFIER: (["a"-"z", "A"-"Z"])+>
}

SimpleNode Program()      : {} 
{
    ClassDeclaration() <EOF> {return jjtn000;}
}

void ClassDeclaration()                   : {/*@bgen(jjtree) class_declaration */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASS_DECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) class_declaration */
    try {
/*@egen*/
    <CLASS> <IDENTIFIER> [<EXT> <IDENTIFIER>] 
    <LBRACE> (VarDeclaration())* (<PUBLIC> (MainDeclaration() | MethodDeclaration()))* <RBRACE> <SEMI>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration()     : {/*@bgen(jjtree) var */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var */
    try {
/*@egen*/
    Type() <IDENTIFIER> <SEMI>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  
}

void MainDeclaration()      : {/*@bgen(jjtree) main */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) main */
    try {
/*@egen*/
    <STAT> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> <IDENTIFIER> <RPAREN> 
    <LBRACE>  (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RBRACE> <SEMI>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/   
}

// Como certificar que o tipo do return \u00c3\u00a9 o mesmo que o "return em si"? Prolly so em analise semantica
void MethodDeclaration()        : {/*@bgen(jjtree) method */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) method */
    try {
/*@egen*/
    (Type() Method() <RETURN> Expression() <SEMI> <RBRACE>
    | <VOID> Method() [<RETURN> <SEMI>] <RBRACE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    
}

void Method(): {/*@bgen(jjtree) Method */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Method */
    try {
/*@egen*/
    <IDENTIFIER> <LPAREN> [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*] <RPAREN>
    <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (Statement())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type(): {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <INT> [<LBRACK> <RBRACK>]
    | <BOOL>
    | <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement()      : {}
{
    <LBRACE> (Statement())* <RBRACE>
    | While()
    | If()
    | Expression() <SEMI>
    | <IDENTIFIER> (<EQUAL> Expression() <SEMI> | <LBRACK> Expression() <RBRACK> <EQUAL> Expression() <SEMI>)   
}

void While(): {/*@bgen(jjtree) While */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) While */
    try {
/*@egen*/
    <WHILE> <LPAREN> Expression() <RPAREN> Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void If(): {/*@bgen(jjtree) If */
  SimpleNode jjtn000 = new SimpleNode(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF> <LPAREN> Expression() <RPAREN> Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Ver como distinguir boolean expressions de arithmetic
void Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    /*
    Expression() (<AND> | <LOWER> | <BIGGER> | <ADD> | <SUB> | <MUL> | <DIV>)* Expression()   
    | Expression() <LBRACK> <RBRACK> Expression()
    | Expression() <DOT> "length"
    | Expression() <DOT> <IDENTIFIER> <LPAREN> [Expression() (<COMMA> Expression())*] <RPAREN>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <INTEGER>
    | <NEW> <INT> <LBRACK> Expression() <RBRACK>
    | <NEW> <IDENTIFIER> <LPAREN> <RPAREN> //E classes com argumentos no construtor?
    | <NOT> Expression()
    | <LPAREN> Expression() <RPAREN> */
}