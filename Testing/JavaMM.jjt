options 
{
    LOOKAHEAD = 1;
    ERROR_REPORTING = true;
}

PARSER_BEGIN(JavaMM)

    import java.io.FileInputStream;

    public class JavaMM
    {
        public static void main(String[] args) throws Exception
        {
            if(args.length < 1)
            {
                System.out.println("Usage: JavaMM <filename>");
                System.exit(1);
            }

            JavaMM parser = new JavaMM(new FileInputStream(args[0]));
            SimpleNode root = parser.Program();

            System.out.println("-----AST-----");
            root.dump(" ");
            
        }
    }

PARSER_END(JavaMM)

SKIP :
{
    " " 
    | "\r" 
    | "\t"
    | "\n"
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN:
{
    
    <BOOL: "boolean">
    | <MAIN: "main">
    | <VOID: "void">
    | <STRING: "String">
    | <INT: ("int")>
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <ADD: "+">
    | <SUB: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <NOT: "!">
    | <EQUAL: "=">
    | <LOWER: "<">
    | <BIGGER: ">">
    | <AND: "&&">
    | <SEMI: ";">
    | <COMMA: ",">
    | <DOT: ".">
    | <RETURN: "return">
    | <PUBLIC: "public">
    | <STAT: "static">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <CLASS: "class">
    | <EXT: "extends">
    | <LENGTH: "length">
    | <LITERAL: (<INTEGER> | <BINARY> | <HEX> | <OCTAL>)>
    | <OCTAL: "0"(["0"-"7"])+>
    | <HEX: "0x"(["0"-"9", "A"-"F"])+>
    | <BINARY: "0b"(["0"-"1"])+>
    | <INTEGER: (<DIGIT>)+>
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <LETTER: ["$", "a"-"z", "A"-"Z", "_"]>
    | <DIGIT: ["0"-"9"]>
}

SimpleNode Program(): {} 
{
    ClassDeclaration() <EOF> {return jjtThis;}
}

void ClassDeclaration() #Class: {Token n;}
{
    <CLASS>  n=<IDENTIFIER> {jjtThis.name = n.image;} [<EXT> <IDENTIFIER>] 
    <LBRACE> (VarDeclaration())* (<PUBLIC> (MainDeclaration() | Method()))* <RBRACE>
}

void VarDeclaration() #Var: {Token n; String t;}
{
    t=Type() {jjtThis.type = t;} n=<IDENTIFIER> {jjtThis.name = n.image;} <SEMI>  
}

void MainDeclaration() #Main: {}
{
    <STAT> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> <IDENTIFIER> <RPAREN> 
    <LBRACE>  (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RBRACE>  
}

void Method(): {Token n; String r;}
{
    r=Type() {jjtThis.returnType = r;} n=<IDENTIFIER> {jjtThis.name = n.image;} <LPAREN> [Arg() 
    (<COMMA> Arg())*] <RPAREN> <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (Statement())*
    Return() <SEMI> <RBRACE>
}

void Return(): {}
{
    <RETURN> Expression() 
}

void Arg(): {Token n; String t;}
{
    t=Type() {jjtThis.type = t;} n=<IDENTIFIER> {jjtThis.name = n.image;}
}

String Type() #void: {Token t, t1;}
{
    t=<INT> [<LBRACK> t1=<RBRACK> {return "int[]";}] {return t.image;}
    | t=<BOOL> {return t.image;}
    | t=<IDENTIFIER> {return t.image;}
}

void Statement() #void: {}
{
    <LBRACE> (Statement())* <RBRACE>
    | While()
    | If()
    | Stmt()
}

void Stmt() #void: {}
{
    LOOKAHEAD(2) lhs() <EQUAL> Expression() <SEMI> #EQUALS(2)
    | Expression() <SEMI> #Stmt
}

void lhs(): {Token n;}
{
    n=<IDENTIFIER> {jjtThis.name = n.image;} [<LBRACK> Expression() <RBRACK>]
}

void While(): {}
{
    try
    {
        <WHILE> <LPAREN> Expression() <RPAREN> 
    }
    catch(ParseException e)
    {
        System.out.println(e.toString());

        error_skip_to(LBRACE);
    }

    Statement()
}

void If(): {}
{
    <IF> <LPAREN> Expression() <RPAREN> Statement() Else()
}

void Else(): {}
{
    <ELSE> Statement()
}

void Member(): {Token n;}
{
    <DOT> (n=<LENGTH> {jjtThis.name = n.image;} | 
    n=<IDENTIFIER> {jjtThis.name = n.image;} <LPAREN> [Expression() (<COMMA> Expression())*] <RPAREN>)
}

void Expression(): {Token n;}
{
    EXPR() [<LBRACK> EXPR() <RBRACK> {jjtThis.type = "array";} | Member()]
    | <NEW> (n=<IDENTIFIER> {jjtThis.name = "new " + n.image;} <LPAREN> <RPAREN> 
        | <INT> {jjtThis.type = "int[]";} <LBRACK> Expression() <RBRACK>)
}

void EXPR()  #void: {}
{
    EXPR_2() (<AND> EXPR_2() #AND(2))*   
}

void EXPR_2()  #void: {}
{
    EXPR_3() (<LOWER> EXPR_3() #LOWER(2))* 
} 

void EXPR_3()  #void: {}
{
    EXPR_4() (ADDSUB())*
}

void ADDSUB() #void: {}
{
    <ADD> EXPR_4() #ADD(2)
    | <SUB> EXPR_4() #SUB(2)
}

void EXPR_4() #void: {}
{
    EXPR_5() (MULDIV())*
}

void MULDIV() #void: {}
{
    <MUL> EXPR_5() #MUL(2)
    | <DIV> EXPR_5() #DIV(2)
}

void EXPR_5() #void: {}
{
    EXPR_6()
    | <NOT> EXPR_6() #NOT(1)
}

void EXPR_6() #TERM: {Token t; Boolean b = false;}
{
    [<SUB> {b = true;}] t=<LITERAL> {jjtThis.name = t.image; if(b) jjtThis.name = "-" + jjtThis.name;}
    | t=<THIS> {jjtThis.name = t.image;} 
    | t=<TRUE> {jjtThis.name = t.image;}
    | t=<FALSE> {jjtThis.name = t.image;}
    | t=<IDENTIFIER> {jjtThis.name = t.image;}
    | <LPAREN> EXPR() #ENCLOSED_EXPR <RPAREN>
}

JAVACODE
void error_skip_to(int kind) #void
{
    Token t;

    do 
    {
      t = getNextToken();
    } 
    while (t.kind != kind);
  }